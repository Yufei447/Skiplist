{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww17280\viewh13200\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs36 \cf0 #include <chrono>  // For timestamp\
\
template<typename K, typename V>\
class Node \{\
public:\
    Node() \{\}\
    Node(K k, V v, int, std::chrono::milliseconds expiration = std::chrono::milliseconds::zero());\
    ~Node();\
\
    K get_key() const;\
    V get_value() const;\
    void set_value(V);\
\
    Node<K, V> **forward;\
    Node<K, V>* prev;  // Previous node in the doubly linked list\
    Node<K, V>* next;  // Next node in the doubly linked list\
\
    std::chrono::steady_clock::time_point expiration_time;  // Expiration time\
    int node_level;\
\
private:\
    K key;\
    V value;\
\};\
\
template<typename K, typename V>\
Node<K, V>::Node(const K k, const V v, int level, std::chrono::milliseconds expiration) \{\
    this->key = k;\
    this->value = v;\
    this->node_level = level;\
\
    // Set expiration time\
    this->expiration_time = std::chrono::steady_clock::now() + expiration;\
\
    this->forward = new Node<K, V>*[level + 1];\
    memset(this->forward, 0, sizeof(Node<K, V>*) * (level + 1));\
\
    this->prev = nullptr;\
    this->next = nullptr;\
\}\
\
\
\
\
#include <unordered_map>\
#include <list>\
\
template <typename K, typename V>\
class SkipList \{\
public:\
    SkipList(int max_level, std::chrono::milliseconds default_expiration);\
    ~SkipList();\
    int insert_element(K key, V value);\
    bool search_element(K key);\
    void delete_element(K key);\
    void expire_elements();\
    void display_list();\
\
private:\
    int get_random_level();\
    Node<K, V>* create_node(K key, V value, int level, std::chrono::milliseconds expiration);\
    void remove_node(Node<K, V>* node);\
\
    int _max_level;\
    int _skip_list_level;\
    Node<K, V>* _header;\
\
    std::unordered_map<K, Node<K, V>*> node_map;  // Fast lookups by key\
    std::list<Node<K, V>*> lru_list;  // LRU eviction\
    std::chrono::milliseconds default_expiration;\
    std::mutex mtx;\
\};\
\
\
\
\
\
\
template<typename K, typename V>\
int SkipList<K, V>::insert_element(K key, V value) \{\
    std::lock_guard<std::mutex> lock(mtx);\
\
    Node<K, V>* current = _header;\
    Node<K, V>* update[_max_level + 1];\
    memset(update, 0, sizeof(Node<K, V>*) * (_max_level + 1));\
\
    for (int i = _skip_list_level; i >= 0; i--) \{\
        while (current->forward[i] != nullptr && current->forward[i]->get_key() < key) \{\
            current = current->forward[i];\
        \}\
        update[i] = current;\
    \}\
\
    current = current->forward[0];\
\
    if (current != nullptr && current->get_key() == key) \{\
        current->set_value(value);\
        return 1;\
    \}\
\
    int random_level = get_random_level();\
    if (random_level > _skip_list_level) \{\
        for (int i = _skip_list_level + 1; i < random_level + 1; i++) \{\
            update[i] = _header;\
        \}\
        _skip_list_level = random_level;\
    \}\
\
    Node<K, V>* new_node = create_node(key, value, random_level, default_expiration);\
\
    for (int i = 0; i <= random_level; i++) \{\
        new_node->forward[i] = update[i]->forward[i];\
        update[i]->forward[i] = new_node;\
    \}\
\
    // Add to hash map and LRU list\
    node_map[key] = new_node;\
    lru_list.push_front(new_node);\
\
    return 0;\
\}\
\
template<typename K, typename V>\
void SkipList<K, V>::expire_elements() \{\
    auto now = std::chrono::steady_clock::now();\
    while (!lru_list.empty()) \{\
        Node<K, V>* node = lru_list.back();\
        if (node->expiration_time > now) \{\
            break;\
        \}\
        remove_node(node);\
        lru_list.pop_back();\
    \}\
\}\
\
template<typename K, typename V>\
void SkipList<K, V>::remove_node(Node<K, V>* node) \{\
    for (int i = 0; i <= node->node_level; i++) \{\
        if (_header->forward[i] == node) \{\
            _header->forward[i] = node->forward[i];\
        \} else \{\
            Node<K, V>* prev = _header;\
            while (prev->forward[i] != node) \{\
                prev = prev->forward[i];\
            \}\
            prev->forward[i] = node->forward[i];\
        \}\
    \}\
\
    node_map.erase(node->get_key());\
    delete node;\
\}\
\
template<typename K, typename V>\
bool SkipList<K, V>::search_element(K key) \{\
    std::lock_guard<std::mutex> lock(mtx);\
    expire_elements();\
\
    if (node_map.find(key) == node_map.end()) \{\
        std::cout << "Key: " << key << " not found." << std::endl;\
        return false;\
    \}\
\
    Node<K, V>* node = node_map[key];\
    if (node->expiration_time < std::chrono::steady_clock::now()) \{\
        remove_node(node);\
        lru_list.remove(node);\
        std::cout << "Key: " << key << " expired." << std::endl;\
        return false;\
    \}\
\
    // Move the node to the front of the LRU list\
    lru_list.remove(node);\
    lru_list.push_front(node);\
\
    std::cout << "Found key: " << key << ", value: " << node->get_value() << std::endl;\
    return true;\
\}\
\
\
\
\
\
\
\
template<typename K, typename V>\
SkipList<K, V>::~SkipList() \{\
    Node<K, V>* node = _header->forward[0];\
    while (node != nullptr) \{\
        Node<K, V>* next = node->forward[0];\
        delete node;\
        node = next;\
    \}\
    delete _header;\
\}}